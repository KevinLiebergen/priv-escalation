#!/usr/bin/python3

from techniques.config.constants import open_green
from techniques.config.constants import open_red
from techniques.config.constants import close
from techniques.config.utilities import print_title_technique
from techniques.config.utilities import print_mitigation

import subprocess
import os

def print_exploitation_message():
	text = "( Exploitation For Privilege Escalation )"
	print_title_technique(text)


# Linux Exploit Suggester
def execute_les(base_path='.'):
	print(open_green + "\nSearching information system and posible exploits for this kernel based on Linux Exploit Suggester (https://github.com/mzet-/linux-exploit-suggester)\n" + close)
	subprocess.call([base_path + "/techniques/config/linux-exploit-suggester.sh"])
	#os.system("wget -q -O - https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh | bash 2> /dev/null")	


def execute_les_2():
	print(open_green + "\nSearching posible exploits for this kernel based on Linux Exploit Suggester 2 (https://github.com/jondonas/linux-exploit-suggester-2)\n" + close)
	#os.system("./config/linux-exploit-suggester-2.pl")
	subprocess.call(["./techniques/config/linux-exploit-suggester-2.pl"])
	#os.system("wget -q -O - https://raw.githubusercontent.com/jondonas/linux-exploit-suggester-2/master/linux-exploit-suggester-2.pl | perl 2> /dev/null")


def search_upgradable_programs():
	print(open_green + "\nSearching software to upgrade since last apt-get update\n" + close)
	out = subprocess.Popen(['apt', 'list', '--upgradable'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	stdout, stderr = out.communicate()
	# Printing software to update except line if use with caution apt in scripts
	print(stdout.decode('utf-8').partition('\n\n')[2])
	return True if 'upgradable' in stdout.decode("utf-8") else False


# Check if app is in a docker container
def check_app_isolated():
	print(open_green + "\nChecking if application is using sandboxing or is dockerized\n"+ close)
	out = subprocess.Popen(['cat', '/proc/1/cgroup'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	stdout, stderr = out.communicate()

	return False if ':/docker/' not in stdout.decode("utf-8") else True


def print_app_not_dockerized():
	print(open_red + "\n[+] Appplication is not using docker\n" + close)


def print_app_dockerized():
	print(open_green + "\n[+] Application is using docker\n"+ close)


def print_system_updated():
	print(open_green + "\n[+] Your system is successfuly updated since the last apt-get update.\n" + close)

def mitigation_app_isolation():
	text = ("Make it difficult for adversaries to advance their operation through "
	"exploitation of undiscovered or unpatched vulnerabilities by using sandboxing. "
	"Other types of virtualization and application microsegmentation may also "
	"mitigate the impact of some types of exploitation. Risks of additional "
	"exploits and weaknesses in these systems may still exist.")
	print_mitigation(text)


def mitigation_threat_program():
	text = ("Develop a robust cyber threat intelligence capability to determine "
	"what types and levels of threat may use software exploits and 0-days "
	"against a particular organization.")
	print_mitigation(text)


def mitigation_update_software():
	text = ("Update software regularly by employing patch management for "
	"internal enterprise endpoints and servers.")
	print_mitigation(text)


def analyze(base_path='.'):
	print_exploitation_message()	
	execute_les(base_path=base_path) # Linux Exploit Suggester
	execute_les_2()
	if search_upgradable_programs():
		mitigation_update_software()
	else:
		print_system_updated()
		
	if check_app_isolated():
		print_app_dockerized()
		mitigation_app_isolation()
	else:
		print_app_not_dockerized()
		mitigation_app_isolation()

	mitigation_threat_program()
